# 如何在点对点网络中“大海捞针”（上）


*简单介绍Kademlia原理*


### 前言


如果有人突然问你："怎么快速从人群中定位一个人？"你可能会一头雾水，人群茫茫多，两三个人还好，想要在一大堆人里精准的定位一个人就如同大海捞针一般困难，这个难题也是点对点网络所要面对的。在点对点网络中，网络中的所有节点在其他节点看来都是类似的，如果要和其中某个节点进行通讯，必要步骤之一就是定位到你想要通讯的节点。不过还好，计算机技术的发展让这个难题有了解决方案，从最早的中心化服务器解决办法，再到Tapestry、Chord，又发展到Kademila，Discv，基于分布式哈希表DHT的点对点网络技术为我们从茫茫节点中精准定位提供了富有美感的解决方案。这篇文章我们就以经典的Kademlia技术为例子，了解一下点对点网络中是如何进行定位与通信的吧。


### 异或运算XOR


在开始之前，我们需要了解计算机中一种重要的位运算方式——XOR异或运算。所谓异或运算，是指在二进制位中计算结果的一种运算方式，其特点在于只有位的输入值不同的时候，输出结果才会是True（在二进制中表示为1），相同的输入位则输出False（二进制中表示为0）。用二进制表达会更加简单明了：
<br>数字100的二进制表示是1100100，而数字123用二进制表达则为1111011，我们对1100100和1111011进行XOR异或运算，其结果则为：<br>

```
XOR
1100100
1111011
---
0011111
```

上述公式中，1100100和1111011的XOR异或运算结果为0011111，十进制表达为31。异或运算是非常重要的逻辑函数，在Kadmlia中被用作计算节点与节点之间的距离，并根据距离对节点进行分类。接下来我们将继续了解Kademlia的工作原理。


### Kademlia的网络拓补结构


在Kademlia中，进入网络的每一个节点都会被分配一个独一无二的节点ID，节点ID以二进制的形式表示，原始Kadmlia协议中使用160位二进制数作为节点ID。任意两个节点的距离可以通过XOR异或运算轻松得出，即节点间距离=（A的ID）XOR（B的ID）。由于Kadmlia采用二进制表示节点的ID，故其网络结构也可以表达为二叉树结构。如下图所示：

![KademliaTree](https://github.com/Cyanglacier/WIPs/blob/master/assets/WIP-2/Pictures/Kademlia.png.png)

上图中我们模拟了在3bits位数下从H到O总共8个节点的Kademlia网络拓补结构图，看起来有点像Merkel Tree，不过构建方式与Merkel Tree不同。在Kademila中，节点会根据自己的ID以及其保存的网络中其他节点ID的共同前缀来构建二叉树结构，这里的"共同前缀"被称作LCP（最长公共前缀Longest Common Prefix），指的是**节点与其他节点ID前缀值相同的位数**。举个例子，节点L的ID为011，节点O的ID为000，由于节点O与节点L只有ID第一位是相同的，故他们的LCP为1。网络将根据节点LCP的不同给予不同的分组，在上述的八个节点中，我们从节点L（ID：011）的视角来看，其节点前缀分组可有三大类：

1、LCP=0，这些节点没有前缀与011向同，包含了节点H、节点I、节点J与节点K；

2、LCP=1，这些节点的第一位与011相同，包含节点N与节点O；

3、LCP=2，这些节点前两位与011相同，只有节点M符合这个条件

从上面LCP的规律我们可以看出，LCP数值越大，节点和另一个节点的相似位数越多，也就代表着彼此之间的距离越近。另一个特点则是，LCP为0的节点总是占据了全部节点数量的一半，，而LCP为1的节点数量则约等于全部节点数量的1/4。值得注意的是，我们前文所提到的**"距离"，并不是指节点之间的物理距离，而是指逻辑距离**。两个节点间的物理距离哪怕有中国到美国那么远，他们的逻辑距离也可能只存在1个bit位的差距。另外位了确保点对点网络的节点能作为中继节点/终端节点正常工作，Kademlia协议还要求了每个节点必须要知道其所在二叉树叶端至少一个节点（若所在叶端只有自身1个节点，则需要知道其他子树的节点信息），这样在其他节点发起交流请求时，节点自身可以正常传播信息。


### K-Bucket（K桶）概述


在上面的二叉树例子中，我们知道了根据LCP的不同，节点可以分作不同类别。将这些节点信息根据前缀以及二叉树结构分类并储存的结构被称为"Bucket"，意即像水桶一样装下节点的信息。上文我们可以知道，LCP=0包含了全网中一半的节点信息，而LCP=0作为Bucket的结构之一，如果不加以限制，单个Bucket里将必然储存全网近50%的节点信息，如果点对点我网络不断发展，不断有新的节点涌入，势必会导致Bucket里信息的不断增大，单个节点需要维护的信息就越多，占用的空间也越多，最终出现"状态爆炸"的问题。为了解决分布式网络中节点的储存问题，Kademlia限制了单个节点中单个Bucket的节点信息储存上限，这个上限值便是K，这种设计也被称作K-Bucket。

……
*更多精彩还请稍稍等待*

