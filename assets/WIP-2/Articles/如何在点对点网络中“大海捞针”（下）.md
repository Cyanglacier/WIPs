# 如何在点对点网络中“大海捞针”（下）

*简单介绍kadmlia*

### K-Bucket
由于储存和网络门槛限制，单个Bucket中是不能储存所有网路节点信息的，另一方面，为了加快点对点网络中节点与节点之间检索和通信的效率，通过一个K值来限制单个Bucket中节点信息的数量，再将节点信息根据LCP分类置入Bucket中，这样每个Bucket都代表了不同距离的节点（如果某个距离的节点数量过多，那么只会有K个数量的节点信息进入到Bucket中，节点也只负责维护Bucket内的节点信息），就能在其他节点发起查询信息时迅速根据距离反馈信息。

老样子，我们还是以之前的3bits位数的节点示意图作为例子。假设其中一个节点K刚刚加入网络，想要生成K=2的Bucket，那么它会有如下步骤：

+ 生成初始Bucket，初始Bucket默认为空
+ 节点K开始在网络中寻找节点，首先回应它的是节点H，节点H与节点K的LCP为1。
+ 节点K将节点H的信息放入初始Bucket，并将初始Bucket设为Bucket-1（LCP=1）
+ 节点H将自己所维护的节点信息向节点K推送，于是节点K知道了以下节点信息：①LCP=0的节点有节点O，节点N，节点L，节点M；②LCP=1的节点有节点H，节点I；③LCP＝２的节点有节点J。
+ 节点K根据节点H发来的信息，将其他节点规划入相应的Bucket中。根据LCP的不同，生成了Bucket-0（LCP=0），Bucket-1，Bucket-2，以及包含自己节点信息的Bucket-3。
+ 由于K=2，单个Bucket中只能存入2个节点的信息，而LCP=0的节点有4个，根据通讯结果，节点K决定在Bucket-0中只存入节点O与节点L。整个Bucket的示意图如下：

![K-bucket示意图](https://github.com/Cyanglacier/WIPs/raw/master/assets/WIP-2/Pictures/K-bucket%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

如果有新的节点进入到了网络，节点和新节点进行通讯，并根据情况选择是否更新自己所维护的Bucket信息：
+ 如果与新节点具备相同LCP的Bucket中，所有节点可以正常通讯，并且Bucket中没有空余位置，那么节点将不会把新节点信息纳入到Bucket中
+ 如果与新节点具备相同LCP的Bucket还有空余位置，或者Bucket已满但有节点无法通讯，那么新节点的信息将会被纳入到Bucket中，并将无法通讯的节点信息从Bucket中剔除。

Bucket的存在让节点可以根据LCP迅速的对网络中所有节点进行分类，并在作为通讯中介节点时迅速定位起始节点，它还是“路由表”这个重要概念的基础，降低了点对点网络中单个节点的储存负担，不可谓之不重要。


### 路由表与通讯
