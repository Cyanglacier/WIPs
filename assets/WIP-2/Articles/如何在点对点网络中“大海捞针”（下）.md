# 如何在点对点网络中“大海捞针”（下）

*简单介绍kadmlia*

### K-Bucket
由于储存和网络门槛限制，单个Bucket中是不能储存所有网路节点信息的，另一方面，为了加快点对点网络中节点与节点之间检索和通信的效率，通过一个K值来限制单个Bucket中节点信息的数量，再将节点信息根据LCP分类置入Bucket中，这样每个Bucket都代表了不同距离的节点（如果某个距离的节点数量过多，那么只会有K个数量的节点信息进入到Bucket中，节点也只负责维护Bucket内的节点信息），就能在其他节点发起查询信息时迅速根据距离反馈信息。

老样子，我们还是以之前的3bits位数的节点示意图作为例子。假设其中一个节点K刚刚加入网络，想要生成K=2的Bucket，那么它会有如下步骤：

+ 生成初始Bucket，初始Bucket默认为空
+ 节点K开始在网络中寻找节点，首先回应它的是节点H，节点H与节点K的LCP为1。
+ 节点K将节点H的信息放入初始Bucket，并将初始Bucket设为Bucket-1（LCP=1）
+ 节点H将自己所维护的节点信息向节点K推送，于是节点K知道了以下节点信息：①LCP=0的节点有节点O，节点N，节点L，节点M；②LCP=1的节点有节点H，节点I；③LCP＝２的节点有节点J。
+ 节点K根据节点H发来的信息，将其他节点规划入相应的Bucket中。根据LCP的不同，生成了Bucket-0（LCP=0），Bucket-1，Bucket-2，以及包含自己节点信息的Bucket-3。
+ 由于K=2，单个Bucket中只能存入2个节点的信息，而LCP=0的节点有4个，根据通讯结果，节点K决定在Bucket-0中只存入节点O与节点L。整个Bucket的示意图如下：

![K-bucket示意图](https://github.com/Cyanglacier/WIPs/raw/master/assets/WIP-2/Pictures/K-bucket%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

如果有新的节点进入到了网络，节点和新节点进行通讯，并根据情况选择是否更新自己所维护的Bucket信息：
+ 如果与新节点具备相同LCP的Bucket中，所有节点可以正常通讯，并且Bucket中没有空余位置，那么节点将不会把新节点信息纳入到Bucket中
+ 如果与新节点具备相同LCP的Bucket还有空余位置，或者Bucket已满但有节点无法通讯，那么新节点的信息将会被纳入到Bucket中，并将无法通讯的节点信息从Bucket中剔除。

Bucket的存在让节点可以根据LCP迅速的对网络中所有节点进行分类，并在作为通讯中介节点时迅速定位起始节点，它还是“路由表”这个重要概念的基础，降低了点对点网络中单个节点的储存负担，不可谓之不重要。


### 路由表与通讯

路由表（Routing Table）是在点对点网络中储存了网络节点信息的一种数据库。在Kademlia中，一个节点如果想同其他节点发起通讯，那么首先要做的就是查阅路由表中有无储存相应节点的信息，前文所提到的K-Bucket在这个过程中就起到了路由表的作用。如果路由表中没有所有节点的信息，那么节点将通过计算两者之间的逻辑距离，再通过路由表中逻辑距离相同的节点进行中介通讯，不断查询直到获得所需节点信息为止。

在原论文中比较形象的解释了节点查讯某一节点并与之通讯的全过程，这里为了方便理解，我们依然以之前的3bits简化网络拓补图作为例子：

![路由](https://github.com/Cyanglacier/WIPs/raw/master/assets/WIP-2/Pictures/Kademlia%20Routning.png)

节点K（100）维护了K=2的数个Bucket，如果它想要同节点N进行通讯，那么它需要进行以下步骤：
+ 查阅目前所维护的路由表，其形式类似于前文K-Bucket的示意图
+ 发现路由表中没有节点N（001）的信息，通过异或运算得出节点N的LCP为0
+ 由于路由表中，LCP=2的Bucket-2储存有节点O（000）的信息，节点K向节点O发起通讯，请求节点N的信息，此为图示①步骤
+ 节点O通过异或运算得出节点N与自己的LCP为2，在自己所维护的路由表中找到了节点N的信息，同时向节点N和节点K发送彼此的位置信息，此为图示②步骤
+ 节点N和节点K收到了彼此的位置信息，发起沟通。此为图示③步骤。至此，节点K完成了和节点N的通讯，他们的中继节点为节点O。

节点的路由表并非是一成不变的，由于其构成基础K-Bucket会随着节点的加入和离线不断更新，实际上每个节点所维护的路由表也是在不断更新的。当新节点经由种子节点加入网络后，种子网络会提供给新节点自身路由表的备份，新节点向路由表中的各个节点依次发起通讯，其他节点收到通讯后会根据自身所维护的路由表和Buckets实际情况选择性地更新路由表状态，而新节点也可借此机会更新自身的路由表。


### 结语

以上便是Kademlia点对点网络结构的基本构成，Kademlia距今已有近20年的历史，得益于其优秀的设计，Kademlia仍然被诸多项目应用。区块链作为去中心化网络，也是Kademlia算法的常客，Wisdom Chain的点对点通讯协议便是基于Kademlia算法，在原始设计的基础上，根据区块链网络的特殊性进行了修改，例如将位数拓展到256位（原算法为160位），以适应区块链网络节点几何增长的情况。当然点对点网络不仅仅只有Kademlia这一个算法，目前比较知名的算法还包括以太坊所用的Discv 4，拓补结构松散的Freenet等。技术的发展是无止境的，点对点网络也是如此，未来相信会有更加优秀的算法出现，降低区块链网络的准入门槛，为我们提供更加舒适的使用体验。
